# dvKovalchuk

1. Породжувальний шаблон - Фабричний метод (Factory Method)
Проблема
Нехай необхідний застосунок для логістики. Спочатку він працює лише з вантажівками (Truck). Через деякий час потрібно додати морські перевезення (Ship). Якщо скрізь у коді прописано new Truck(), то додавання нового класу змушує переписувати більшість існуючого коду - він сильно пов'язаний з конкретним класом.
Фабричний метод вирішує цю проблему: він виносить створення об'єктів у спеціальний метод, який підкласи можуть перевизначати. Клієнтський код більше не залежить від конкретних класів.
Ідея реалізації
Оголошується інтерфейс (абстрактний клас) для продукту (Transport).
Оголошується Creator з абстрактним factory_method().
Кожен ConcreteCreator перевизначає factory_method() і повертає свій тип продукту.
Клієнтський код викликає factory_method() через інтерфейс Creator, не знаючи, який саме об'єкт буде створено.
UML-діаграма
'''
┌─────────────────────┐         ┌──────────────────┐
│  <<abstract>>       │         │  <<abstract>>    │
│  Logistics          │         │  Transport       │
│─────────────────────│         │──────────────────│
│ + factory_method()  │────────►│ + deliver(): str │
│ + plan_delivery()   │         └──────────────────┘
└─────────────────────┘                  ▲
         ▲                      ┌────────┼─────────┐
         │                      │        │         │
┌────────┼────────┐          ┌──┴──┐  ┌──┴─┐  ┌───┴──┐
│        │        │          │Truck│  │Ship│  │Plane │
│        │        │          │─────│  │────│  │──────│
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ RoadLogistics│  │ SeaLogistics │  │ AirLogistics │
│──────────────│  │──────────────│  │──────────────│
│factory_method│  │factory_method│  │factory_method│
│ → Truck()    │  │ → Ship()     │  │ → Plane()    │
└──────────────┘  └──────────────┘  └──────────────┘

2. Структурний шаблон - Міст (Bridge)
Проблема
Нехай є фігури: Circle і Square. Тепер потрібно додати кольори: Red і Blue. Без шаблону «Міст» виникне комбінаторний вибух класів: RedCircle, BlueCircle, RedSquare, BlueSquare. Якщо додати третій колір - ще 2 класи. Якщо третю фігуру - ще 3 класи.
Міст розділяє ієрархію на два незалежні виміри: абстракцію (що робимо) та реалізацію (як робимо). Замість успадкування - композиція через агрегацію.
Ідея реалізації
Код розділений на два незалежні виміри, які з'єднані через поле self.color - це і є «міст»:
Вимір 1 - Абстракція (фігури): абстрактний клас Shape зберігає посилання на об'єкт Color і делегує йому відповідальність за колір. Конкретні фігури (Circle, Square, Triangle) лише реалізують метод draw(), всередині якого звертаються до self.color.fill() - але не знають, який саме колір там буде.
Вимір 2 - Реалізація (кольори): абстрактний клас Color оголошує метод fill(). Конкретні кольори (Red, Blue, Green) повертають свою назву. Вони нічого не знають про фігури.
Завдяки такому розділенню, щоб додати новий колір - достатньо створити один клас-спадкоємець Color. Щоб додати нову фігуру - один клас-спадкоємець Shape. Жодна зміна в одному вимірі не зачіпає інший.
UML-діаграма
'''
АБСТРАКЦІЯ                          РЕАЛІЗАЦІЯ
─────────────────────────────       ────────────────────────
                                    
┌────────────────────────────┐      ┌────────────────────┐
│      Shape                 │      │      Color         │
│  <<abstract>>              │      │   <<abstract>>     │
│────────────────────────────│      │────────────────────│
│ - color: Color             │─────►│ + fill(): str      │
│────────────────────────────│      └────────────────────┘
│ + __init__(color: Color)   │                ▲
│ + draw(): str              │       ┌────────┼────────┐
└────────────────────────────┘       │        │        │
              ▲                   ┌──┴──┐  ┌──┴──┐  ┌──┴───┐
    ┌─────────┼─────────┐         │ Red │  │Blue │  │Green │
    │         │         │         │─────│  │─────│  │──────│
┌───┴──┐  ┌───┴──┐  ┌───┴────┐    │fill │  │fill │  │fill  │
│Circle│  │Square│  │Triangle│    │→    │  │→    │  │→     │
│──────│  │──────│  │────────│    │"чер"│  │"син"│  │"зел" │
│draw()│  │draw()│  │draw()  │    └─────┘  └─────┘  └──────┘
└──────┘  └──────┘  └────────┘
'''

3. Поведінковий шаблон - Ланцюжок обов'язків (Chain of Responsibility)
Проблема
У системі обробки запитів часто потрібно кілька рівнів перевірки або обробки підряд: автентифікація → авторизація → валідація → кешування → бізнес-логіка. Якщо жорстко зв'язати їх в одному місці — код стає монолітним, важко розширювати і тестувати кожен рівень окремо.
Ланцюжок обов'язків пропонує передавати запит через ланцюжок обробників. Кожен обробник вирішує: опрацювати запит самостійно чи передати далі по ланцюжку. Відправник не знає, хто саме обробить запит.
Ідея реалізації
Кожен Handler зберігає посилання на наступний обробник (next_handler).
Метод handle() або обробляє запит, або викликає next_handler.handle().
Клієнт складає ланцюжок у потрібному порядку та відправляє запит першому.
UML-діаграма

'''
    Client ──► [AuthHandler] ──► [RateLimitHandler] ──► [ValidationHandler] ──► [BusinessHandler]
                │                    │                       │                       │
          перевіряє токен      рахує запити           перевіряє поля         виконує логіку
          якщо ні → стоп       якщо ліміт → стоп      якщо немає → стоп

┌──────────────────────────────────┐
│  <<abstract>> Handler            │
│──────────────────────────────────│
│ - _next: Handler                 │
│ + set_next(handler) -> Handler   │
│ + handle(request) -> str | None  │
└──────────────────────────────────┘
              ▲
    ┌─────────┼──────────────┐
    │         │              │
┌───┴───┐ ┌───┴──────┐  ┌────┴──────────┐ ┌───────────────┐
│ Auth  │ │RateLimit │  │  Validation   │ │ BusinessLogic │
│Handler│ │ Handler  │  │    Handler    │ │    Handler    │
└───────┘ └──────────┘  └───────────────┘ └───────────────┘
'''
